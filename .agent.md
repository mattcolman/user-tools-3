# Forge Confluence Context Menu App

## Project Overview

- A Forge app that adds a context menu item to Confluence
- Main functionality:
  - Extracts @mentions from selected text
  - Displays user information in a tabbed interface:
    - Email addresses
    - Full names
    - Avatars (planned feature)
  - Provides "Copy All" functionality for each data type
- Built with React and Forge Custom UI
- Uses Jira REST API for user lookups

## Tech Stack

- Node.js 22.x runtime
- React 18.x
- Forge platform libraries:
  - @forge/bridge: For API communication
  - @forge/resolver: For function resolution
- React Scripts for development tooling
- ESLint for code quality
- Atlaskit CSS Reset for consistent styling

## Project Structure

```
.
├── src/
│   └── index.js              # Backend resolver functions
├── static/
│   └── hello-world/         # Frontend React application
│       ├── public/          # Static assets
│       │   └── index.html   # HTML entry point
│       └── src/             # React source code
│           ├── App.js       # Main React component
│           └── index.js     # React entry point
├── .eslintrc                # ESLint configuration
├── manifest.yml             # Forge app configuration
└── package.json            # Dependencies and scripts
```

## Key Files

- `manifest.yml`: Defines app modules, permissions, and runtime configuration
- `src/index.js`: Backend resolver functions for the Forge app
- `static/hello-world/src/App.js`: Main React component implementing the UI
- `static/hello-world/public/index.html`: HTML template for the React app

## Development Practices

### Code Organization

- Keep React components focused and single-purpose
- Use consistent file structure for new features
- Maintain separation between UI and API logic
- Follow React Hooks patterns for state management

### State Management

- Use React Hooks for state management
- Key state elements:
  - selectedText: The text selected by the user
  - userData: Object containing user information
  - activeTab: Current selected tab
  - error/loading states
  - copySuccess: Feedback state

### API Integration

- Use requestJira from @forge/bridge for Jira API calls
- Implement proper error handling for API calls
- Cache API responses where appropriate
- Use proper error boundaries

### Error Handling

- Implement try/catch blocks for async operations
- Display user-friendly error messages
- Log errors to console for debugging
- Handle both API and runtime errors

### UI/UX Guidelines

- Use the Atlassian design system (ADS)
- - Components https://atlassian.design/llms-components.txt: Documentation for ADS Component
- - Primitives https://atlassian.design/llms-primitives.txt: Documentation for ADS Primitives (low-level building blocks)
- - Tokens https://atlassian.design/llms-tokens.txt: Documentation for using ADS Tokens
- - Styling https://atlassian.design/llms-styling.txt: Documentation for styling with ADS

## Build and Deploy

### Build Steps

1. Install root dependencies: `npm install`
2. Install frontend dependencies: `cd static/hello-world && npm install`
3. Build the frontend: `npm run build`
4. Return to root: `cd ../..`
5. Deploy: `forge deploy`

### Quick Deploy

Use the provided deploy script:

```bash
npm run deploy
```

### Development Workflow

1. Make code changes
2. Run `forge lint` to check for issues
3. Use `forge tunnel` for local development
4. Deploy changes with `npm run deploy`

### Required Permissions

- `read:jira-user`: For user lookups
- `read:confluence-user`: For Confluence integration

## Common Tasks

### Adding New Features

1. Create new components in `static/hello-world/src/`
2. Update App.js to integrate new components
3. Test locally using `forge tunnel`
4. Deploy using `npm run deploy`

### Debugging

- Check browser console for frontend errors
- Use loading and error states for debugging
- Monitor API responses in console.log statements
- Test with various text selections

### Testing

- Test with different types of selected text
- Verify @mention extraction
- Check error handling
- Test loading states
- Verify copy functionality
- Test tab switching behavior
- Ensure responsive layout
